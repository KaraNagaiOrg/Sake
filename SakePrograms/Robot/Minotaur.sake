hairetsu exits = {2};
exits[0] = [28, 10, 8, osu];
exits[1] = [29, 8, 8, osu];

hairetsu myState = {1};
myState[0] = [25, 9, 5, 0];

seisu kansu printMaze(hairetsu mazeMatrix) kido
    shuki x = 0 : 30 kido
        shuki y = 0 : 30 kido
            shuki z = 0 : 30 kido
                sorenara ~(ruikei <mazeMatrix[x, y, z, 0], undefined>) kido
                    #senden 11111111;
                    senden [x, y, z, mazeMatrix[x, y, z, 1]];
                    senden mazeMatrix[x, y, z, 0];
                    senden mazeMatrix[x, y, z, 2];
                    senden mazeMatrix[x, y, z, 3];
                    #senden 22222222;
                shushi;
            shushi;
        shushi;
    shushi;
    modoru 0;
shushi;

seisu kansu replenish(hairetsu mazeMatrix, hairetsu add) kido
    shuki i = 0 : nagasa add kido
        mazeMatrix[add[i] => X, add[i] => Y, add[i] => Z, 0] = 1; #gray
        mazeMatrix[add[i] => X, add[i] => Y, add[i] => Z, 1] = add[i] => kabe;
        ronri isExit = osu;
        shuki e = 0 : nagasa exits kido
            sorenara eqCube(exits[e], add[i]) kido
                isExit = shinri;
            shushi;
        shushi;
        mazeMatrix[add[i] => X, add[i] => Y, add[i] => Z, 2] = isExit;
        mazeMatrix[add[i] => X, add[i] => Y, add[i] => Z, 3] = -1;
    shushi;

    modoru 0;
shushi;

ronri kansu eqCube(rippotai c1, rippotai c2) kido
    modoru ~(c1=>X > c2=>X v c1=>X < c2=>X) ^ ~(c1=>Y > c2=>Y v c1=>Y < c2=>Y) ^ ~(c1=>Z > c2=>Z v c1=>Z < c2=>Z) ^ (c1=>kabe ^ c2=>kabe v ~c1=>kabe ^ ~c2=>kabe);
shushi;

seisu kansu findWay(hairetsu mazeMatrix, hairetsu exits) kido
    senden exits;
    printMaze(mazeMatrix);
    senden 1111111;
    lookAround(mazeMatrix);
    printMaze(mazeMatrix);
    modoru 0;
shushi;

seisu kansu lookAround(hairetsu mazeMatrix) kido
    modoru replenish(mazeMatrix, {^-0; v-0; <-0; >-0; o-0; ~-0});
shushi;

hairetsu mazeMatrix = {30, 30, 30, 4};
replenish(mazeMatrix, myState);
replenish(mazeMatrix, exits);

findWay(mazeMatrix, exits);